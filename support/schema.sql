BEGIN;

CREATE TABLE contents (
  id   INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  hash BYTEA NOT NULL,
  body BYTEA NOT NULL,

  -- If we have a hash collision we're in trouble.  Technically we
  -- don't even need this to be unique---plain index would be just as
  -- fine.  But we want it for upsert.
  UNIQUE (hash)
);

CREATE TABLE content_fixes (
  broken_id INTEGER NOT NULL
            REFERENCES contents(id)
            ON UPDATE CASCADE
            ON DELETE CASCADE
            DEFERRABLE INITIALLY DEFERRED,
  fixed_id  INTEGER
            REFERENCES contents(id)
            ON UPDATE CASCADE
            ON DELETE SET NULL
            DEFERRABLE INITIALLY DEFERRED,

  UNIQUE (broken_id, fixed_id)
);

CREATE TABLE pastes (
  id          INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created     TIMESTAMPTZ DEFAULT now(),
  updates     TIMESTAMPTZ[] DEFAULT ARRAY[now()],
  provider    VARCHAR NOT NULL,
  provider_id VARCHAR NOT NULL,
  content_id  INTEGER
              REFERENCES contents(id)
              ON UPDATE CASCADE
              ON DELETE SET NULL
              DEFERRABLE INITIALLY DEFERRED,

  UNIQUE (content_id, provider, provider_id)
);

CREATE INDEX ON pastes(provider_id);

CREATE TABLE versions (
  id          INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at  TIMESTAMPTZ DEFAULT now(),
  title       VARCHAR,
  description VARCHAR,

  UNIQUE(title)
);

CREATE TABLE analysis (
  content_id INTEGER NOT NULL
             REFERENCES contents(id)
             ON UPDATE CASCADE
             ON DELETE CASCADE
             DEFERRABLE INITIALLY DEFERRED,
  version_id INTEGER NOT NULL
             REFERENCES versions(id)
             ON UPDATE CASCADE
             ON DELETE CASCADE
             DEFERRABLE INITIALLY DEFERRED,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ,
  summary    JSONB,

  PRIMARY KEY (content_id, version_id)
);

COMMIT;
